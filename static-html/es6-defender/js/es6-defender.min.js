/**
 * @license
 * es6-defender.min.js - v0.0.1
 *
 * Licensed under the MIT License.
 * http://github.com/markpurser/es6-defender/LICENSE
*/

'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// -------------------------------------------------------------------------------------------------------------------------------------------
// constants and enums
// -------------------------------------------------------------------------------------------------------------------------------------------
var PlayerState = Object.freeze({ faceLeft: 1, faceRight: 2, exploding: 3 });

var InvaderState = Object.freeze({ seeking: 1, locked: 2, abducting: 3, mutant: 4, exploding: 5, explodingReleaseHuman: 6 });

var Event = Object.freeze({ locked: 1, abducted: 2, mutated: 3, dead: 4, removeProjectile: 5, removeHuman: 6, playerDead: 7, collectedHuman: 8, removeDebris: 9 });

var easing = 0.05;
var playerAccelX = 520;
var playerDampingX = 6;
var playerMaxSpeedX = 164;
var playerMaxSpeedY = 42;
var debrisDamping = 0.6;
var modulusx = 512;
var halfmodulusx = modulusx / 2;
var starmodulusx = 384;
var halfstarmodulusx = starmodulusx / 2;
var projectileLifetime = 60;
var debrisLifetime = 100;
var pointsLifetime = 200;
var groundOffset = 6;
var colourFlash = -1;

var Global = { viewWidth: 0, viewHeight: 0 };

// -------------------------------------------------------------------------------------------------------------------------------------------
// custom data types
// -------------------------------------------------------------------------------------------------------------------------------------------

var StateVector = function StateVector(id, x, y) {
  var xdot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var ydot = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  _classCallCheck(this, StateVector);

  this.id = id;
  this.x = x;
  this.y = y;
  this.xdot = xdot;
  this.ydot = ydot;
};

var Player = function (_StateVector) {
  _inherits(Player, _StateVector);

  function Player(id, x, y, state, t_startState) {
    _classCallCheck(this, Player);

    var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this, id, x, y));

    _this.state = state;
    _this.t_startState = t_startState;
    return _this;
  }

  return Player;
}(StateVector);

var Invader = function (_StateVector2) {
  _inherits(Invader, _StateVector2);

  function Invader(id, x, y, state, t_startState) {
    _classCallCheck(this, Invader);

    var _this2 = _possibleConstructorReturn(this, (Invader.__proto__ || Object.getPrototypeOf(Invader)).call(this, id, x, y));

    _this2.state = state;
    _this2.t_startState = t_startState;
    return _this2;
  }

  return Invader;
}(StateVector);

var Human = function (_StateVector3) {
  _inherits(Human, _StateVector3);

  function Human(id, x, y, xdot, ydot) {
    _classCallCheck(this, Human);

    return _possibleConstructorReturn(this, (Human.__proto__ || Object.getPrototypeOf(Human)).call(this, id, x, y, xdot, ydot));
  }

  return Human;
}(StateVector);

var Projectile = function (_StateVector4) {
  _inherits(Projectile, _StateVector4);

  function Projectile(id, x, y, xdot, ydot, t_spawned) {
    _classCallCheck(this, Projectile);

    var _this4 = _possibleConstructorReturn(this, (Projectile.__proto__ || Object.getPrototypeOf(Projectile)).call(this, id, x, y, xdot, ydot));

    _this4.t_spawned = t_spawned;
    return _this4;
  }

  return Projectile;
}(StateVector);

var Debris = function (_StateVector5) {
  _inherits(Debris, _StateVector5);

  function Debris(id, x, y, xdot, ydot, t_spawned) {
    _classCallCheck(this, Debris);

    var _this5 = _possibleConstructorReturn(this, (Debris.__proto__ || Object.getPrototypeOf(Debris)).call(this, id, x, y, xdot, ydot));

    _this5.t_spawned = t_spawned;
    return _this5;
  }

  return Debris;
}(StateVector);

var Points = function (_StateVector6) {
  _inherits(Points, _StateVector6);

  function Points(id, x, y, xdot, ydot, t_spawned, points) {
    _classCallCheck(this, Points);

    var _this6 = _possibleConstructorReturn(this, (Points.__proto__ || Object.getPrototypeOf(Points)).call(this, id, x, y, xdot, ydot));

    _this6.t_spawned = t_spawned;
    _this6.points = points;
    return _this6;
  }

  return Points;
}(StateVector);

var Star = function (_StateVector7) {
  _inherits(Star, _StateVector7);

  function Star(id, x, y, depth) {
    _classCallCheck(this, Star);

    var _this7 = _possibleConstructorReturn(this, (Star.__proto__ || Object.getPrototypeOf(Star)).call(this, id, x, y));

    _this7.depth = depth;
    return _this7;
  }

  return Star;
}(StateVector);

// -------------------------------------------------------------------------------------------------------------------------------------------
// custom data type statics
// -------------------------------------------------------------------------------------------------------------------------------------------


Player.sideLen = 4;
Player.graphic = ['\xab\xac\xad\xae\n\xbb\xbc\xbd\xbe\n\xcb\xcc\xcd\xce\n\xdb\xdc\xdd\xde', '\xa6\xa7\xa8\xa9\n\xb6\xb7\xb8\xb9\n\xc6\xc7\xc8\xc9\n\xd6\xd7\xd8\xd9'];
Player.colour = 0x00ccff;

Invader.sideLen = 4;
Invader.graphic = '\xa1\xa2\xa3\xa4\n\xb1\xb2\xb3\xb4\n\xc1\xc2\xc3\xc4\n\xd1\xd2\xd3\xd4';
Invader.graphicAbducting = '\xa1\xa2\xa3\xa4\n\xb1\xb2\xb3\xb4\n\xc1\xc2\xc3\xc4\n\xd1\xd2\xd3\xd4\n \xe1\xe2 \n \xf1\xf2';
Invader.colour = 0x00ff00;
Invader.colourMutant = colourFlash;

Human.sideLen = 2;
Human.graphic = '\xe1\xe2\n\xf1\xf2';
Human.colour = 0x00aa99;

Projectile.sideLen = 2;
Projectile.graphic = '--';
Projectile.graphic2 = '\xe6\xe7\n\xf6\xf7';
Projectile.colour = 0xffff00;
Projectile.colour2 = 0xffcc00;

Debris.graphic = '@';
Debris.colour = 0xff88ff;

Points.colour = colourFlash;

Star.graphic = '.';
Star.colour = colourFlash;

// -------------------------------------------------------------------------------------------------------------------------------------------
// generic functions
// -------------------------------------------------------------------------------------------------------------------------------------------
var wrapx = function wrapx(x) {
  if (x < -halfmodulusx) x += modulusx;else if (x >= halfmodulusx) x -= modulusx;
  return x;
};

var wrapstarx = function wrapstarx(x) {
  if (x < -halfstarmodulusx) x += starmodulusx;else if (x >= halfstarmodulusx) x -= starmodulusx;
  return x;
};

var toLocal = function toLocal(sv) {
  var lx = sv.x - offsetx;
  lx += Global.viewWidth / 2;

  var ly = sv.y;

  return { id: sv.id, lx: lx, ly: ly, gx_debug: sv.x };
};

var clip = function clip(lcoords) {
  return lcoords.lx >= 0 && lcoords.lx < Global.viewWidth;
};

var remove = function remove(objects, id, graphics) {
  var o = objects.findIndex(function (o) {
    return o.id == id;
  });
  objects.splice(o, 1);
  graphics.delete(id);
};

var fillWith = function fillWith(n, f) {
  return Array(n).fill().map(f);
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// collision functions
// -------------------------------------------------------------------------------------------------------------------------------------------
var cartesianProduct2 = function cartesianProduct2(arr1, arr2) {
  return arr1.map(function (e1) {
    return arr2.map(function (e2) {
      return [e1, e2];
    });
  }).reduce(function (arr, e) {
    return arr.concat(e);
  }, []);
};

var toTuples = function toTuples(arr) {
  return arr.map(function (a) {
    return { fst: a[0], snd: a[1] };
  });
};

var xoverlap = function xoverlap(x1, size1, x2, size2) {
  return x2 < x1 + size1 && x1 < x2 + size2;
};

var yoverlap = function yoverlap(y1, size1, y2, size2) {
  return y2 < y1 + size1 && y1 < y2 + size2;
};

var collided = function collided(_ref, size1, _ref2, size2) {
  var x1 = _ref.x,
      y1 = _ref.y;
  var x2 = _ref2.x,
      y2 = _ref2.y;
  return xoverlap(x1, size1, x2, size2) && yoverlap(y1, size1, y2, size2);
};

var detectCollisions = function detectCollisions(svArr1, size1, svArr2, size2) {
  return toTuples(cartesianProduct2(svArr1, svArr2)).filter(function (svPair) {
    return collided(svPair.fst, size1, svPair.snd, size2);
  }).map(function (collidedPair) {
    return { id1: collidedPair.fst.id, id2: collidedPair.snd.id };
  });
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// update state
// -------------------------------------------------------------------------------------------------------------------------------------------
var updatePlayerState = function updatePlayerState(player, input, playerDead) {
  if (playerDead) {
    player.state = PlayerState.exploding;
    return;
  }

  if (input.leftright != 0) {
    player.state = input.leftright == -1 ? PlayerState.faceLeft : PlayerState.faceRight;
  }
};

var updateInvaderState = function updateInvaderState(invaders, events, t) {
  events.map(function (e) {
    if (e.event == Event.locked || e.event == Event.abducted || e.event == Event.dead || e.event == Event.mutated) {
      var _Event$locked$Event$a;

      var idx = invaders.findIndex(function (i) {
        return i.id == e.invaderId;
      });
      var i = invaders[idx];
      i.state = (_Event$locked$Event$a = {}, _defineProperty(_Event$locked$Event$a, Event.locked, InvaderState.locked), _defineProperty(_Event$locked$Event$a, Event.abducted, InvaderState.abducting), _defineProperty(_Event$locked$Event$a, Event.mutated, InvaderState.mutant), _defineProperty(_Event$locked$Event$a, Event.dead, i.state == InvaderState.abducting ? InvaderState.explodingReleaseHuman : InvaderState.exploding), _Event$locked$Event$a)[e.event];
      i.t_startState = t;
    }
  });
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// update position
// -------------------------------------------------------------------------------------------------------------------------------------------
var updatePlayerPosition = function updatePlayerPosition(sv, input, dt) {
  sv.xdot += playerAccelX * input.leftright * dt;
  sv.ydot = playerMaxSpeedY * input.updown;

  if (sv.xdot < -playerMaxSpeedX) sv.xdot = -playerMaxSpeedX;
  if (sv.xdot > playerMaxSpeedX) sv.xdot = playerMaxSpeedX;

  if (!input.leftright) sv.xdot += -playerDampingX * sv.xdot * dt;

  sv.x = 0;
  sv.y += sv.ydot * dt;

  if (sv.y < 0) sv.y = 0;
  if (sv.y > Global.viewHeight - groundOffset - 4) sv.y = Global.viewHeight - groundOffset - 4;

  return sv;
};

var updateInvaderPosition = function updateInvaderPosition(sv, state, targetx, targety, dt) {
  var _InvaderState$seeking;

  var a = (_InvaderState$seeking = {}, _defineProperty(_InvaderState$seeking, InvaderState.seeking, function () {
    sv.xdot += 72 * (Math.random() - 0.5) * dt;
    sv.ydot += 72 * (Math.random() - 0.5) * dt;
    sv.x += sv.xdot * dt;
    sv.y += sv.ydot * dt;

    if (sv.y < 5) {
      sv.ydot = -sv.ydot;sv.y = 5;
    }
    if (sv.y > Global.viewHeight - 5) {
      sv.ydot = -sv.ydot;sv.y = Global.viewHeight - 5;
    }
  }), _defineProperty(_InvaderState$seeking, InvaderState.locked, function () {
    sv.xdot = targetx;
    sv.ydot = 12;

    sv.x += sv.xdot * dt;
    sv.y += sv.ydot * dt;
  }), _defineProperty(_InvaderState$seeking, InvaderState.abducting, function () {
    sv.ydot = -12;

    sv.y += sv.ydot * dt;
  }), _defineProperty(_InvaderState$seeking, InvaderState.mutant, function () {
    sv.xdot += dt * (targetx - sv.x) > 0 ? 1.2 : -1.2;
    sv.ydot += dt * (targety - sv.y) > 0 ? 1.2 : -1.2;

    sv.xdot += -1.2 * sv.xdot * dt;
    sv.ydot += -1.2 * sv.ydot * dt;

    sv.x += sv.xdot * dt;
    sv.y += sv.ydot * dt;
  }), _defineProperty(_InvaderState$seeking, InvaderState.exploding, function () {}), _defineProperty(_InvaderState$seeking, InvaderState.explodingReleaseHuman, function () {}), _InvaderState$seeking)[state]();

  return sv;
};

var updateHumanPosition = function updateHumanPosition(sv, dt) {
  sv.x += sv.xdot * dt;
  sv.y += sv.ydot * dt;

  return sv;
};

var updateProjectilePosition = function updateProjectilePosition(sv, dt) {
  sv.x += sv.xdot * dt;
  sv.y += sv.ydot * dt;

  return sv;
};

var updateDebrisPosition = function updateDebrisPosition(d, dt) {
  updateProjectilePosition(d, dt);

  d.xdot += -debrisDamping * d.xdot * dt;
  d.ydot += -debrisDamping * d.ydot * dt;

  return d;
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// update position helpers
// -------------------------------------------------------------------------------------------------------------------------------------------
var updateInvaderPositions = function updateInvaderPositions(invaders, invaderTargets, player, dt) {
  return invaders.map(function (i) {
    var targetx = 0,
        targety = 0;
    if (i.state == InvaderState.mutant) {
      targetx = player.x;
      targety = player.y;
    } else if (invaderTargets.has(i.id)) {
      targetx = invaderTargets.get(i.id).humanXDot;
    }
    updateInvaderPosition(i, i.state, targetx, targety, dt);
  });
};

var updateHumanPositions = function updateHumanPositions(humans, dt) {
  return humans.map(function (h) {
    return updateHumanPosition(h, dt);
  });
};

var updateProjectilePositions = function updateProjectilePositions(projectiles, dt) {
  return projectiles.map(function (p) {
    return updateProjectilePosition(p, dt);
  });
};

var updateDebrisPositions = function updateDebrisPositions(debris, dt) {
  return debris.map(function (d) {
    return updateDebrisPosition(d, dt);
  });
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// check state and generate events
// -------------------------------------------------------------------------------------------------------------------------------------------
var checkSeekingInvader = function checkSeekingInvader(invader, humans) {
  var inRangeHumans = humans.filter(function (h) {
    return xoverlap(invader.x, Invader.sideLen, h.x, Human.sideLen);
  });
  if (inRangeHumans.length > 0) {
    if (Math.random() < 0.05) {
      return [{ event: Event.locked, invaderId: invader.id, humanId: inRangeHumans[0].id, humanXDot: inRangeHumans[0].xdot }];
    }
  }
  return [];
};

var checkLockedInvader = function checkLockedInvader(invader, e) {
  return invader.y + Invader.sideLen >= Global.viewHeight - groundOffset ? [{ event: Event.abducted, invaderId: invader.id, humanId: e.humanId }, { event: Event.removeHuman, id: e.humanId }] : [];
};

var checkAbductingInvader = function checkAbductingInvader(invader) {
  return invader.y <= 0 ? [{ event: Event.mutated, invaderId: invader.id }] : [];
};

var checkHitInvaders = function checkHitInvaders(invaders, projectiles) {
  return detectCollisions(invaders, Invader.sideLen, projectiles, Projectile.sideLen).reduce(function (arr, collidedPair) {
    return arr.concat([{ event: Event.dead, invaderId: collidedPair.id1 }, { event: Event.removeProjectile, id: collidedPair.id2 }]);
  }, []);
};

var checkHitPlayerProjectiles = function checkHitPlayerProjectiles(player, projectiles) {
  return detectCollisions([player], Player.sideLen, projectiles, Projectile.sideLen).map(function (collidedPair) {
    return { event: Event.playerDead };
  });
};

var checkHitPlayerInvaders = function checkHitPlayerInvaders(player, invaders) {
  return detectCollisions([player], Player.sideLen, invaders, Invader.sideLen).map(function (collidedPair) {
    return { event: Event.playerDead };
  });
};

var checkHitPlayerHumans = function checkHitPlayerHumans(player, humans) {
  return detectCollisions([player], Player.sideLen, humans, Human.sideLen).reduce(function (arr, collidedPair) {
    return arr.concat([{ event: Event.collectedHuman }, { event: Event.removeHuman, id: collidedPair.id2 }]);
  }, []);
};

var checkProjectiles = function checkProjectiles(projectiles, t) {
  return projectiles.filter(function (p) {
    return t - p.t_spawned > projectileLifetime;
  }).map(function (p) {
    return { event: Event.removeProjectile, id: p.id };
  });
};

var checkDebris = function checkDebris(debris, t) {
  return debris.filter(function (d) {
    return t - d.t_spawned > debrisLifetime;
  }).map(function (d) {
    return { event: Event.removeDebris, id: d.id };
  });
};

var checkPoints = function checkPoints(points, t) {
  return points.filter(function (p) {
    return t - p.t_spawned > pointsLifetime;
  }).map(function (p) {
    return { event: Event.removePoints, id: p.id };
  });
};

var invaderFire = function invaderFire(i, player, invaderProjectileId, t) {
  var dx = player.x - i.x;
  if (Math.random() < 0.01 && Math.abs(dx) < Global.viewWidth / 3) {
    var dy = player.y - i.y;
    var l = Math.sqrt(dx * dx + dy * dy);
    var unitdx = dx / l;
    var unitdy = dy / l;
    return new Projectile(invaderProjectileId, i.x, i.y, unitdx * 60, unitdy * 60, t);
  }
  return null;
};

var makeExplosion = function makeExplosion(debris, debrisId, i, t) {
  var velocities = [[42, 42], [60, 0], [42, -42], [0, -60], [-42, -42], [-60, 0], [-42, 42], [0, 60]];
  velocities.map(function (v) {
    debris.push(new Debris(debrisId++, i.x, i.y, v[0], v[1], t));
  });
  return debrisId;
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// game state variables
// -------------------------------------------------------------------------------------------------------------------------------------------
var offsetx = 0;
var targetoffsetx = 0;
var playerId = null;
var invaderId = null;
var player = null;
var invaders = null;
var humanId = null;
var humans = null;
var projectileId = null;
var projectiles = null;
var invaderProjectileId = null;
var invaderProjectiles = null;
var starfield = null;
var debrisId = null;
var debris = null;
var pointsId = null;
var points = null;
var graphics = null;
var invaderTargets = null;
var score = null;

// -------------------------------------------------------------------------------------------------------------------------------------------
// reset game state
// -------------------------------------------------------------------------------------------------------------------------------------------
var resetGame = function resetGame(viewWidth, viewHeight, sound) {

  Global.viewWidth = viewWidth;
  Global.viewHeight = viewHeight;

  playerId = 1;
  invaderId = 100;
  player = new Player(playerId, 0, viewHeight / 2, PlayerState.faceRight, 0);
  invaders = fillWith(10, function (_) {
    return new Invader(invaderId++, (Math.random() * 0.8 + 0.2) * halfmodulusx * [1, -1][Math.floor(Math.random() * 2)], viewHeight / 2, InvaderState.seeking, 0);
  });
  humanId = 200;
  humans = fillWith(10, function (_) {
    return new Human(humanId++, (Math.random() - 0.5) * modulusx, viewHeight - groundOffset, 12 * (Math.random() - 0.5));
  });
  projectileId = 500;
  projectiles = [];
  invaderProjectileId = 1000;
  invaderProjectiles = [];
  starfield = fillWith(50, function (_) {
    return new Star(2000, (Math.random() - 0.5) * starmodulusx, Math.random() * viewHeight, Math.random() * 0.5 + 0.5);
  });
  debrisId = 3000;
  debris = [];
  pointsId = 5000;
  points = [];
  graphics = new Map();
  invaderTargets = new Map();
  score = 0;

  sound('1up');
};

// -------------------------------------------------------------------------------------------------------------------------------------------
// run a single game tick
// -------------------------------------------------------------------------------------------------------------------------------------------
var doGame = function doGame(textmap, input, sound, t, dt) {
  var debug = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;


  // player fire button
  if (input.fire) {
    sound('zap');
    projectiles.push(new Projectile(projectileId++, player.x, player.y + 2, player.state == PlayerState.faceLeft ? -240 : 240, 0, t));
    if (projectileId >= 1000) projectileId = 500;
  }

  // filter invaders according to state
  var seekingInvaders = invaders.filter(function (i) {
    return i.state == InvaderState.seeking;
  });
  var lockedInvaders = invaders.filter(function (i) {
    return i.state == InvaderState.locked;
  });
  var abductingInvaders = invaders.filter(function (i) {
    return i.state == InvaderState.abducting;
  });
  var mutantInvaders = invaders.filter(function (i) {
    return i.state == InvaderState.mutant;
  });

  // invader fire
  seekingInvaders.map(function (i) {
    var p = invaderFire(i, player, invaderProjectileId, t);
    if (p) {
      invaderProjectiles.push(p);
      invaderProjectileId++;
    }
  });

  mutantInvaders.map(function (i) {
    var p = invaderFire(i, player, invaderProjectileId, t);
    if (p) {
      invaderProjectiles.push(p);
      invaderProjectileId++;
    }
    if (Math.random() < 0.02) {
      invaderProjectiles.push(new Projectile(invaderProjectileId++, i.x, i.y, (Math.random() - 0.5) * 60, (Math.random() - 0.5) * 60, t));
    }
  });

  if (invaderProjectileId >= 1500) invaderProjectileId = 1000;
  if (invaderProjectiles.length > 30) remove(invaderProjectiles, invaderProjectiles[0].id, graphics);

  // events
  var projectileEvents = checkProjectiles(projectiles, t);
  var debrisEvents = checkDebris(debris, t);
  var pointsEvents = checkPoints(points, t);

  var hitEvents = checkHitInvaders(invaders, projectiles);

  var playerProjectileHitEvent = checkHitPlayerProjectiles(player, invaderProjectiles);
  var playerInvaderHitEvent = checkHitPlayerProjectiles(player, invaders);
  var playerHumanHitEvent = checkHitPlayerHumans(player, humans);

  var seekingInvaderEvents = seekingInvaders.reduce(function (arr, i) {
    return arr.concat(checkSeekingInvader(i, humans));
  }, []);
  var lockedInvaderEvents = lockedInvaders.reduce(function (arr, i) {
    return arr.concat(checkLockedInvader(i, invaderTargets.get(i.id)));
  }, []);
  var abductingInvaderEvents = abductingInvaders.reduce(function (arr, i) {
    return arr.concat(checkAbductingInvader(i));
  }, []);

  var invaderEvents = [].concat(hitEvents, seekingInvaderEvents, lockedInvaderEvents, abductingInvaderEvents);

  var allEvents = [].concat(projectileEvents, playerProjectileHitEvent, playerInvaderHitEvent, playerHumanHitEvent, invaderEvents, debrisEvents, pointsEvents);
  var playerDead = false;

  allEvents.filter(function (e) {
    return e.event == Event.removeProjectile;
  }).map(function (e) {
    return remove(projectiles, e.id, graphics);
  });
  allEvents.filter(function (e) {
    return e.event == Event.removeDebris;
  }).map(function (e) {
    return remove(debris, e.id, graphics);
  });
  allEvents.filter(function (e) {
    return e.event == Event.removePoints;
  }).map(function (e) {
    return remove(points, e.id, graphics);
  });
  allEvents.filter(function (e) {
    return e.event == Event.locked;
  }).map(function (e) {
    return invaderTargets.set(e.invaderId, e);
  });
  allEvents.filter(function (e) {
    return e.event == Event.removeHuman;
  }).map(function (e) {
    return remove(humans, e.id, graphics);
  });
  allEvents.filter(function (e) {
    return e.event == Event.playerDead;
  }).map(function (e) {
    sound('death');playerDead = true;
  });
  allEvents.filter(function (e) {
    return e.event == Event.collectedHuman;
  }).map(function (_) {
    sound('coin');score += 20000;points.push(new Points(pointsId++, player.x, player.y, 0.01, 0.01, t, '20000'));
  });

  // update game object state
  // game objects are updated 'in-place'
  updatePlayerState(player, input, playerDead);
  updateInvaderState(invaders, invaderEvents, t);

  // update positions
  // game objects are updated 'in-place'
  updatePlayerPosition(player, input, dt);
  updateInvaderPositions(invaders, invaderTargets, player, dt);
  updateHumanPositions(humans, dt);
  updateProjectilePositions(projectiles, dt);
  updateProjectilePositions(invaderProjectiles, dt);
  updateDebrisPositions(debris, dt);
  updateProjectilePositions(points, dt);

  // triggers based on state changes must be placed after state update code

  // abducting invaders drop human when hit
  invaders.filter(function (i) {
    return i.state == InvaderState.explodingReleaseHuman && i.t_startState == t;
  }).map(function (i) {
    return humans.push(new Human(humanId++, i.x + 2, i.y, 0, 6));
  });

  // invader explosion
  invaders.filter(function (i) {
    return i.state == InvaderState.explodingReleaseHuman || i.state == InvaderState.exploding && i.t_startState == t;
  }).map(function (i) {
    sound('boom');
    score += 1000;
    remove(invaders, i.id, graphics);
    // debris updated 'in-place'
    debrisId = makeExplosion(debris, debrisId, i, t);
    if (debrisId >= 4000) debrisId = 3000;
  });

  // prepare to draw
  // update graphics map
  graphics.set(player.id, player.state == PlayerState.faceLeft ? { g: Player.graphic[0], c: Player.colour } : { g: Player.graphic[1], c: Player.colour });

  invaders.map(function (i) {
    var g = i.state == InvaderState.abducting ? Invader.graphicAbducting : Invader.graphic;
    var c = i.state == InvaderState.mutant ? Invader.colourMutant : Invader.colour;
    graphics.set(i.id, { g: g, c: c });
  });
  humans.map(function (h) {
    return graphics.set(h.id, { g: Human.graphic, c: Human.colour });
  });
  projectiles.map(function (p) {
    return graphics.set(p.id, { g: Projectile.graphic, c: Projectile.colour });
  });
  invaderProjectiles.map(function (p) {
    return graphics.set(p.id, { g: Projectile.graphic2, c: Projectile.colour2 });
  });
  starfield.map(function (s) {
    return graphics.set(s.id, { g: Star.graphic, c: Star.colour });
  });
  debris.map(function (d) {
    return graphics.set(d.id, { g: Debris.graphic, c: Debris.colour });
  });
  points.map(function (p) {
    return graphics.set(p.id, { g: p.points, c: 0xffffff });
  });

  // compute displacements
  var displacementList = [].concat(invaders, humans, projectiles, invaderProjectiles, debris, points);

  var displacement = player.xdot * dt;
  displacementList.map(function (o) {
    o.x = wrapx(o.x - displacement);
  });

  starfield.map(function (o) {
    o.x = wrapstarx(o.x - displacement * o.depth);
  });

  var displayList = [].concat(starfield, displacementList, player);

  // draw
  displayList.map(toLocal).filter(clip).map(function (i) {
    var g = graphics.has(i.id) ? graphics.get(i.id) : { g: '!', c: 0xff0000 };
    textmap.setString(Math.floor(i.lx), Math.floor(i.ly), g.g, g.c);
    if (debug) {
      // overlay object id and x coordinate
      textmap.setNumber(Math.floor(i.lx + 3), Math.floor(i.ly), i.id);
      textmap.setNumber(Math.floor(i.lx), Math.floor(i.ly + 4), Math.floor(i.gx_debug));
    }
  });

  textmap.setString(50, 2, 'Score: ');
  textmap.setNumber(57, 2, score);

  // compute offset of local coordinate system
  // shift player to right or left of screen
  player.state == PlayerState.faceLeft ? targetoffsetx = -Global.viewWidth * 0.3 : targetoffsetx = Global.viewWidth * 0.3;
  // apply 'forward motion' effect as player velocity increases
  targetoffsetx -= 0.05 * player.xdot;
  // ease offset towards target offset
  offsetx += easing * (targetoffsetx - offsetx);

  return player.state == PlayerState.exploding;
};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
* retrovision.js
*
* Copyright (C) 2016  Mark Purser
* Released under the MIT license
* http://github.com/markpurser/retrovision/LICENSE
*
* Tile rendering based on
* https://github.com/jice-nospam/yendor.ts
* Copyright (c) 2014 Jice
*/

var RetroVision = function () {
    function RetroVision() {
        _classCallCheck(this, RetroVision);
    }

    _createClass(RetroVision, [{
        key: 'init',
        value: function init(options) {
            var _this = this;

            options = options || {};
            Object.keys(RetroVision.defaults).forEach(function (key) {
                if (!(key in options)) options[key] = RetroVision.defaults[key];
            });

            _this._options = options;

            return new Promise(function (resolve, reject) {
                // create a new instance of a pixi container
                _this._parentContainer = new PIXI.Container();

                _this._tileTextures = [];

                // create a renderer instance
                var pixiOptions = {
                    clearBeforeRender: true,
                    preserveDrawingBuffer: false,
                    resolution: 1,
                    view: options.renderCanvas
                };

                _this._renderer = PIXI.autoDetectRenderer(options.renderCanvasSize.width, options.renderCanvasSize.height, pixiOptions);
                _this._renderer.backgroundColor = 0x0;

                _this._stats = {
                    fpsText: new PIXI.Text('', { font: '24px Arial', fill: 0xff1010 }),
                    fpsTimer: 0,
                    currentFrameCount: 0
                };

                var loader = PIXI.loader;
                loader.add('tilesheet', options.tilesheetImage);

                loader.load(function (loader, resources) {
                    var numTilesX = resources.tilesheet.texture.width / options.tileWidthPx;
                    var numTilesY = resources.tilesheet.texture.height / options.tileHeightPx;

                    // init tile textures
                    for (var x = 0; x < numTilesX; x++) {
                        for (var y = 0; y < numTilesY; y++) {
                            var rect = new PIXI.Rectangle(x * options.tileWidthPx, y * options.tileHeightPx, options.tileWidthPx, options.tileHeightPx);
                            _this._tileTextures[x + y * numTilesX] = new PIXI.Texture(resources.tilesheet.texture, rect);
                        }
                    }

                    _this._worldSpriteContainer = new SpriteGrid(options.viewWidth, options.viewHeight, options.tileWidthPx, options.tileHeightPx, _this._tileTextures[' '.codePointAt(0)]);

                    _this._parentContainer.addChild(_this._worldSpriteContainer.getSpriteContainer());
                    _this._parentContainer.addChild(_this._stats.fpsText);

                    resolve();
                });
            });
        }
    }, {
        key: 'render',
        value: function render() {
            if (this._options.displayStats) {
                this.updateStats(this._stats);
            }

            // render
            this._renderer.render(this._parentContainer);

            // clear screen
            var sprites = this._worldSpriteContainer.getSprites();
            for (var x = 0; x < this._options.viewWidth; x++) {
                for (var y = 0; y < this._options.viewHeight; y++) {
                    var index = x + y * this._options.viewWidth;
                    sprites[index].texture = this._tileTextures[32];
                }
            }
        }
    }, {
        key: 'set',
        value: function set(x, y, tileCode) {
            var colour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffffff;

            if (x < 0 || x >= this._options.viewWidth || y < 0 || y >= this._options.viewHeight) return;

            if (typeof tileCode === 'string') {
                tileCode = tileCode.codePointAt(0);
            }
            var index = x + y * this._options.viewWidth;
            this._worldSpriteContainer.getSprites()[index].texture = this._tileTextures[tileCode];

            if (colour == RetroVision.flash) colour = Math.floor(Math.random() * 0xffffff);
            this._worldSpriteContainer.getSprites()[index].tint = colour;
        }
    }, {
        key: 'setString',
        value: function setString(x, y, tileString) {
            var colour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffffff;

            var X = x;
            for (var c = 0; c < tileString.length; c++) {
                var tileCode = tileString.codePointAt(c);
                if (tileCode == 10) {
                    y++;
                    x = X;
                } else {
                    this.set(x, y, tileCode, colour);
                    x++;
                }
            }
        }
    }, {
        key: 'setNumber',
        value: function setNumber(x, y, number) {
            var colour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffffff;

            this.setString(x, y, number.toString(), colour);
        }
    }, {
        key: 'updateStats',
        value: function updateStats(stats) {
            stats.currentFrameCount++;
            if (stats.fpsTimer === 0) {
                stats.fpsTimer = new Date().getTime();
            } else if (new Date().getTime() - stats.fpsTimer > 1000) {
                var rendererTypeStr = 'Canvas';
                if (this._renderer instanceof PIXI.WebGLRenderer) {
                    rendererTypeStr = 'WebGL';
                }
                stats.fpsText.text = 'fps: ' + stats.currentFrameCount + '\npixi: ' + PIXI.VERSION + '\nRenderer: ' + rendererTypeStr;
                stats.fpsTimer = new Date().getTime();
                stats.currentFrameCount = 0;
            }
        }
    }]);

    return RetroVision;
}();

RetroVision.defaults = {
    renderCanvasSize: { width: 1600, height: 900 },
    tilesheetImage: "assets/terminal.png",
    tileWidthPx: 8,
    tileHeightPx: 8,
    viewWidth: 128,
    viewHeight: 128,
    displayStats: true
};

RetroVision.flash = -1;

var SpriteGrid = function () {
    function SpriteGrid(gridWidth, gridHeight, tileWidthPx, tileHeightPx, tileTexture) {
        _classCallCheck(this, SpriteGrid);

        this.spriteContainer = new PIXI.Container();
        this.sprites = [];

        // init grid
        for (var x = 0; x < gridWidth; x++) {
            for (var y = 0; y < gridHeight; y++) {
                var sprite = new PIXI.Sprite(tileTexture);
                sprite.position.x = x * tileWidthPx;
                sprite.position.y = y * tileHeightPx;
                sprite.width = tileWidthPx;
                sprite.height = tileHeightPx;
                this.sprites[x + y * gridWidth] = sprite;
                this.spriteContainer.addChild(sprite);
            }
        }
    }

    _createClass(SpriteGrid, [{
        key: 'getSpriteContainer',
        value: function getSpriteContainer() {
            return this.spriteContainer;
        }
    }, {
        key: 'getSprites',
        value: function getSprites() {
            return this.sprites;
        }
    }]);

    return SpriteGrid;
}();
//# sourceMappingURL=es6-defender.min.js.map
